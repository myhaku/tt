Command: #action {search string} {commands} {priority}

         Have tintin search for a certain string of text from the mud, if the
         string is found it will execute the commands.  Variables %1 to %99
         are substituted from the input string, and can be used in the command.

         If the search string starts with ~, color codes must be matched, which
         you can see by enabling: #config {convert meta} on.

         The following Perl compatible regular expression options are available:

       ^ force match of start of line.
       $ force match of end of line.
       \ escape one character.
  %1-%99 lazy match of any text, available at %1-%99.
      %0 should be avoided in triggers, and if left alone lists all matches.
     { } embed a raw regular expression, matches are stored to %1-%99.
   %!{ } embed a raw regular expression, matches are not stored.
         [ ] . + | ( ) ? * are treated as normal text unlessed used within
         braces. Keep in mind that { } is replaced with ( ) automatically
         unless %!{ } is used.

         Of the following the (lazy) match is available at %1-%99 + 1

      %d match zero to any number of digits.
      %D match zero to any number of non digits.
      %s match zero to any number of spaces.
      %S match zero to any number of non spaces.
      %w match zero to any number of word characters.
      %W match zero to any number of word characters.

      %? match zero or one character.
      %. match one character.
      %+ match one to any number of characters.
      %* match zero to any number of characters.

      %i matching becomes case insensitive.
      %I matching becomes case sensitive (default).

      The match is automatically stored to a value between %1 and %99
      starting at %1 and incrementing by 1 for every regex. If you use
      %15 as a regular expression, the next unnumbered regular expression
      would be %16. To prevent a match from being stored use %!*, %!w, etc.

      Actions can be triggered by the showme command and certain system
      messages.

Example: #act {^You are hungry$} {get bread backpack;eat bread}
         Performs 2 commands as you get the hunger message, tintin will not
         be fooled by someone saying 'You are hungry'.

Example: #act {%1 tells you 'hello'} {tell %1 Hello %1. How are you today?}
         This allows you to seem like a nice, attentive, fast typing gentleman.

Example: #act {A puppy barks at you, wagging {his|her|its} tail.} {pat puppy}
         This allows you to be nice to puppies regardless of their sex.

Comment: You can remove an action with the #unaction command.

Command: #alias {word} {command}

         Defines a word that when entered executes the given command. If
         any arguments are given they are appended to the end of the command.
         If the command includes variables %0-99, these are substituted as
         part of the parsing.  %0 is set to all text after the word was input,
         %1 is set to the first word following the aliased word, and %2 is the
         second, and so on. If you use %0-99 no arguments are automatically
         appended.

         The word can include the %1 to %99 variables making an alias behave
         like an action, allowing more complex input matching.

Example: #alias gb get bread bag
         Typing gb at the prompt would be sent as 'get bread bag'.

Example: #alias ws {wake;stand}
         Since ws aliases a multiple command, you must use the braces.

Example: #alias heal cast 'heal' %1
         Typing 'heal valgar' would be sent as 'cast 'heal' valgar'.

Comment: See '#help action', for more information about triggers.

Comment: You can remove an alias with the #unalias command.

Command: #all {string}

         Sends a command to all active sessions.

Example: #all quit
         Sends 'quit' to all active sessions.

Command: #bell

         Sends a beep to your terminal.

Example: #action {tells you} {#bell}
         Will chime every time someone gives you a tell.

Command: #break

         The break command can be used inside the #FOREACH, #LOOP, #PARSE,
         #WHILE and #SWITCH statements. When #BREAK is found, tintin will stop
         executing the statement it is currently in and move on to the next.

Example: #while {1} {#math cnt $cnt + 1;#if {$cnt == 20} {#break}}

Command: #buffer {home|up|down|end|lock|clear|info}
         The buffer command allows you to add macros to scroll in case the
         default bindings do not work. The lock options toggles the
         scrolling state of the screen.

         #buffer {find} {number} {text} Jump to the first occasion of text
         or the given occasion by providing the optional number argument.

         #buffer {get} {variable} {line} {range} Store the given line or
         range in the given variable.

         #buffer {lock} {on|off} Lock or unlock the screen. When locked
         new text won't be displayed until the lock is removed. Without
         an argument the lock status is toggled.

         #buffer {write} {filename} Write the buffer to the given file.

Example: #macro {(press ctrl-v)(press F1)} {#buffer end}
         Associates F1 key to 'scroll buffer to its end' command.

Command: #case {conditional} {arguments}

         The case command must be used within the switch command. When the
         conditional argument of the case command matches the conditional
         argument of the switch command the body of the case is executed.

Command: #chat {option} {argument}

         #chat {init}       {port}             Initilizes a chat port.
         #chat {name}       {name}             Sets your chat name.
         #chat {message}    {buddy|all} {text} Sends a chat message

         #chat {accept}     {buddy}            Accept a file transfer
         #chat {call}       {address} {port}   Connect to a buddy
         #chat {cancel}     {buddy}            Cancel a file transfer
         #chat {color}      {color names}      Set the default color
         #chat {decline}    {buddy}            Decline a file transfer
         #chat {dnd}                           Decline new connections
         #chat {download}   {directory}        Set your download directory
         #chat {emote}      {buddy|all} {text} Send an emote message
         #chat {forward}    {buddy}            Forward all chat messages
         #chat {forwardall} {buddy}            Forward all session output
         #chat {filestat}   {buddy}            Show file transfer data
         #chat {group}      {buddy} {name}     Assign a chat group
         #chat {ignore}     {buddy}            Ignores someone
         #chat {info}                          Displays your info
         #chat {ip}         {address}          Changes your IP address
         #chat {paste}      {buddy|all} {text} Pastes a block of text
         #chat {peek}       {buddy}            Show one's public connections
         #chat {ping}       {buddy}            Display response time
         #chat {private}    {buddy|all}        Make a connection private
         #chat {public}     {buddy|all}        Make a connection public
         #chat {reply}      {text}             Reply to last private message
         #chat {request}    {buddy}            Request one's public connections
         #chat {send}       {buddy|all} {text} Sends a raw data string
         #chat {sendfile}   {buddy} {filename} Start a file transfer
         #chat {serve}      {buddy}            Forward all public chat messages
         #chat {uninitialize}                  Uninitialize the chat port.
         #chat {who}                           Show all connections
         #chat {zap}        {buddy}            Close a connection

Command: #class {name} {open|close|list|read|size|write|kill} {arg}

         The {open} option will open a class, closing a previously opened
         class. All triggers added afterwards are assigned to this class.
         The {close} option will close the given class.
         The {list} option will show the given list of the class.
         The {read} option will open the class, read, and close afterwards.
         The {size} option will store the size of the class in a variable.
         The {write} option will write all triggers of the given class to file.
         The {kill} option will delete all triggers of the given class.

         Keep in mind that the kill and read option are very fast allowing
         them to be used to enable and disable classes.

Example: #class extra kill;#class extra read extra.tin
         Deletes all triggers of 'extra' class if any. Read 'extra.tin' file,
         all triggers loaded will be assigned to the fresh new 'extra' class.

Syntax:  <xyz>  with x, y, z being parameters

         Parameter 'x': VT100 code

         0 - Reset all colors and codes to default
         1 - Bold
         2 - Dim
         4 - Underscore
         5 - Blink
         7 - Reverse
         8 - Skip (use previous code)

         Parameter 'y':  Foreground color
         Parameter 'z':  Background color

         0 - Black                5 - Magenta
         1 - Red                  6 - Cyan
         2 - Green                7 - White
         3 - Yellow               8 - Skip
         4 - Blue                 9 - Default

         For xterm 256 colors support use <aaa> to <fff> for RGB foreground
         colors and <AAA> to <FFF> for RGB background colors. For the grayscale
         foreground colors use <g00> to <g23>, for grayscale background colors
         use <G00> to <G23>.

         The tertiary colors are as follows:

         <acf> - Azure            <afc> - Jade
         <caf> - Violet           <cfa> - Lime
         <fac> - Pink             <fca> - Orange

Example: #showme <acf>Azure    <afc>Jade     <caf>Violet
Example: #showme <cfa>Lime     <fac>Pink     <fca>Orange

         For 12 bit truecolor use <F000> to <FFFF> for foreground colors and
         <B000> to <BFFF> for background colors.

         For 24 bit truecolor use \e[38;2;R;G;Bm where R G B are red/green/blue
         intensities between 0 and 255. For example: \e[37;2;50;100;150m. Use
         \e[48;2;R;G;Bm for background colors.

Command: #config {option} {argument}

         This allows you to configure various settings, the settings can be
         written to file with the #write or #writesession command.

         If you configure the global session (the one you see as you start up
         tintin) all sessions started will inherite these settings.

         It's advised to make a configuration file to read on startup if you
         do not like the default settings.

         Config options which aren't listed by default:

         #CONFIG {CHILD LOCK}   {ON|OFF} Enable or disable command input.
         #CONFIG {CONVERT META} {ON|OFF} Shows color codes and key bindings.
         #CONFIG {DEBUG TELNET} {ON|OFF} Shows telnet negotiations y/n.
         #CONFIG {LOG LEVEL}  {LOW|HIGH} LOW logs mud output before triggers.
         #CONFIG {INHERITANCE}  {ON|OFF} Session trigger inheritance y/n.
         #CONFIG {MCCP}         {ON|OFF} Enable or disable MCCP support.

Command: #continue

         The continue command can be used inside the #FOREACH, #LOOP, #PARSE,
         #WHILE and #SWITCH commands. When #CONTINUE is found, tintin will go
         to the end of the command and proceed as normal, which may be to
         reiterate the command.

Example: #loop 1 10 cnt {#if {$cnt % 2 == 0} {#continue} {say $cnt}}

Command: #cr

         Sends a carriage return to the session.  Useful for aliases that need
         extra carriage returns.

Command: #cursor {option} {argument}

         Typing #cursor without an option will show all available cursor
         options. The cursor command's primarly goal is adding customizable
         input editing with macros.

Command: #debug {listname} {on|off|log}

         Toggles a list on or off. With no argument it shows your current
         settings, as well as the list names that you can debug.

         If you for example set ACTIONS to ON you will get debug information
         whenever an action is triggered.

         #debug {listname} {log} will silently write debugging information to
         the log file, you must be logging in order for this to work.

         Not every list has debug support yet.

Command: #default {commands}

         The default command can only be used within the switch command. When
         the conditional argument of non of the case commands matches the switch
         command's conditional statement the default command is executed.

Command: #delay {seconds} {command}
Command: #delay {name} {command} {seconds} 

         Delay allows you to have tintin wait the given amount of seconds
         before executing the given command. tintin won't wait before
         executing following input commands if any.

         Floating point precision for miliseconds is possible.

Example: #showme first;#delay {1} {#showme last}
         This will print 'first', and 'last' around one second later.

Comment: If you want to remove a delay with the #undelay command you can add
         a name as the first argument, be aware this changes the syntax. If
         the name is a number keep in mind that delays with the same numeric
         name will not be overwritten

Command: #echo {format} {argument1} {argument2} {etc}

         Echo command displays text on the screen with formatting options. See
         the help file for the format command for more informations.

         The echo command does not trigger actions.

         As with the #showme command you can split the {format} argument up into
         two braced arguments, in which case the 2nd argument is the row number.

Example: #echo {The current date is %t.} {%Y-%m-%d %H:%M:%S}
         #echo {[%38s][%-38s]} {Hello World} {Hello World}
         #echo {{this is %s on the top row} {-1}} {printed}

Command: #else {commands}

         The else statement should follow an #IF or #ELSEIF statement and is
         only called if the proceeding #IF or #ELSEIF is false.

Example: #if {1d2 == 1} {smile};#else {grin}

Command: #elseif {conditional} {commands}

         The elseif statement should follow an #IF or #ELSEIF statement and is
         only called when the statement is true and the proceeding #IF and
         #ELSEIF statements are false.

Example: #if {1d3 == 1} {smirk};#elseif {1d2 == 1} {snicker}

Command: #end {<message>}

         Terminates tintin and return to unix.  On most systems, ctrl-c has
         the same result.

         The message is optional and is printed before tintin exits. When
         using #end {\} tintin will terminate silently.

         You may use the escape character \ for various special characters.

         \a    beep the terminal.
         \c    send a control character, \ca for ctrl-a.
         \e    start an escape sequence.
         \n    send a line feed.
         \r    send a carriage return.
         \t    send a horizontal tab.
         \x    print an 8 bit character using hexadecimal, \xFF for example.
         \x7B  send the '{' character.
         \x7D  send the '}' character.
         \u    print a 16 bit unicode character, \uFFFD for example.
         \U    print a 21 bit unicode character, \U02AF21 for example.
         \v    send a vertical tab

         Ending a line with \ will stop tintin from appending a line feed.
         To escape arguments in an alias or action use %%0 %%1 %%2 etc.

Command: #event {event type}

         Events allow you to create triggers for predetermined client events.
         Use #event without an argument to see a list of possible events with
         a brief description. Use #event %* to see the current list of defined
         events. Use #info {events} {on} to see events get thrown.

         CHAT MESSAGE          %0 default %1 plain
         CLASS ACTIVATED       %0 class name
         CLASS DEACTIVATED     %0 class name
         DATE                  %1 month - %3 day   %4 hour : %5 minute
         DAY                   %3 day
         DOUBLE-CLICKED <VAR>  %0 col %1 row
         END OF PATH
         HOUR                  %4 hour
         IAC <VAR> <VAR>
         IAC SB GMCP <MODULE>  %0 data     %1 raw data
         IAC SB MSSP           %0 variable %1 value
         IAC SB MSDP           %0 variable %1 value
         IAC SB MSDP <VAR>     %1 value
         IAC SB NEW-ENVIRON    %0 variable %1 value
         IAC SB ZMP <VAR>      %0 value
         IAC SB <VAR>          %0 raw text %1 raw data
         LONG-CLICKED <VAR>    %0 col %1 row %2 -col %3 -row %4 word %5 line
         MAP ENTER MAP         %0 new vnum
         MAP ENTER ROOM        %0 new vnum %1 old vnum
         MAP ENTER ROOM <VAR>  %0 new vnum %1 old vnum
         MAP EXIT MAP          %0 old vnum
         MAP EXIT ROOM         %0 old vnum %1 new vnum
         MAP EXIT ROOM <VAR>   %0 old vnum %1 new vnum
         MINUTE                %5 minute
         MONTH                 %1 month
         MOVED <VAR>           %0 col %1 row %2 -col %3 -row %4 word %5 line
         PORT CONNECTION       %0 name %1 ip %2 port
         PORT DISCONNECTION    %0 name %1 ip %2 port
         PORT MESSAGE          %0 name %1 ip %2 port %3 data %4 raw data
         PRESSED <VAR>         %0 col %1 row %2 -col %3 -row %4 word %5 line
         PROGRAM START         %0 client name %1 client version %2 startup arg
         PROGRAM TERMINATION   %0 goodbye message
         RECEIVED INPUT        %0 raw text
         RECEIVED KEYPRESS     %0 raw text %1 unicode index
         RECEIVED LINE         %0 raw text %1 plain text
         RECEIVED OUTPUT       %0 raw text
         RECEIVED PROMPT       %0 raw text %1 plain text
         RELEASED <VAR>        %0 col %1 row %2 -col %3 -row %4 word %5 line
         SCAN CSV HEADER       %0 all args %1 arg1 %2 arg2 .. %99 arg99
         SCAN CSV LINE         %0 all args %1 arg1 %2 arg3 .. %99 arg99
         SCAN TSV HEADER       %0 all args %1 arg1 %2 arg3 .. %99 arg99
         SCAN TSV LINE         %0 all args %1 arg1 %2 arg3 .. %99 arg99
         SCREEN RESIZE         %0 cols %1 rows
         SCROLLED <VAR>        %0 col %1 row %2 -col %3 -row %4 word %5 line
         SECOND                %6 second
         SEND OUTPUT           %0 raw text
         SESSION ACTIVATED     %0 name
         SESSION CONNECTED     %0 name %1 host %2 ip %3 port
         SESSION CREATED       %0 name %1 host %2 ip %3 port
         SESSION DEACTIVATED   %0 name
         SESSION DISCONNECTED  %0 name %1 host %2 ip %3 port
         SESSION TIMED OUT     %0 name %1 host %2 ip %3 port
         SHORT-CLICKED <VAR>   %0 col %1 row %2 -col %3 -row %4 word %5 line
         TIME                  %4 hour : %5 minute : %6 second
         TRIPLE-CLICKED <VAR>  %0 col %1 row %2 -col %3 -row %4 word %5 line
         UNKNOWN COMMAND       %0 raw text
         VARIABLE UPDATE <VAR> %0 name %1 value
         WEEK                  %2 week
         WINDOW FOCUS IN       %0 name
         WINDOW FOCUS OUT      %0 name
         YEAR                  %0 year

Example: #event {SESSION CONNECTED} {#read mychar.tin}

Comment: You can remove an event with the #unevent command.

Command: #forall {list} {commands}

         List elements must either be separated by braces or semicolons.

Example: #forall {a;b;c;d} {say &0}
Example: #forall {{a}{b}{c}{d}} {say &0}
         Both equal: say a;say b;say c;say d

Command: #foreach {list} {variable} {commands}

         For each item in the provided list the foreach statement will update
         the given variable and execute the command part of the statement. List
         elements must be separated by braces or semicolons.

Example: #foreach {bob;tim;kim} {name} {tell $name Hello}
Example: #foreach {{bob}{tim}{kim}} {name} {tell $name Hello}

Command: #format {variable} {format} {argument1} {argument2} {etc}

         Allows you to store a string into a variable in the exact same way
         C's sprintf works with a few enhancements and limitations such as
         no integer operations and a maximum of 20 arguments.

         If you use #format inside an alias or action you must escape %1s as
         %+1s or %%1s so the %1 isn't substituted by the trigger.

         #format {test} {%+9s} {string}  pad string with up to 9 spaces
         #format {test} {%-9s} {string}  post pad string with up to 9 spaces
         #format {test} {%.8s} {string}  copy at most 8 characters
         #format {test} {%a}   {number}  print corresponding charset character
         #format {test} {%c}   {string}  use a highlight color name
         #format {test} {%d}   {number}  print a number with integer formatting
         #format {test} {%f}   {string}  perform floating point math
         #format {test} {%g}   {number}  perform thousand grouping on {number}
         #format {test} {%h}   {string}  turn text into a header line
         #format {test} {%l}   {string}  lowercase text
         #format {test} {%m}   {string}  perform mathematical calculation
         #format {test} {%n}     {name}  capitalize the first letter
         #format {test} {%p}   {string}  strip leading and trailing spaces
         #format {test} {%r}   {string}  reverse text, hiya = ayih
         #format {test} {%s}   {string}  print given string
         #format {test} {%t}   {format}  display time with strftime format
                                         optional {{format}{time}} syntax
         #format {test} {%u}   {string}  uppercase text
         #format {list} {%w}   {string}  store wordwrapped text in {list}
                                         optional {{string}{width}} syntax
         #format {test} {%x}      {hex}  print corresponding charset character
         #format {test} {%A}     {char}  store corresponding character value
         #format {cols} {%C}         {}  store the screen width in {cols}
         #format {test} {%D}      {hex}  convert hex to decimal in {test}
         #format {hash} {%H}   {string}  store a 64 bit string hash in {hash}
         #format {test} {%L}   {string}  store the string length in {test}
         #format {rows} {%R}         {}  store the screen height in {rows}
         #format {name} {%S}         {}  store the session name in {name}
         #format {time} {%T}         {}  store the epoch time in {time}
         #format {time} {%U}         {}  store the micro epoch time in {time}
         #format {test} {%X}      {dec}  convert dec to hexadecimal in {test}


Command: #function {name} {operation}

         Functions allow you to execute a script within a line of text, and
         replace the function call with the line of text generated by the
         function.

         Be aware that each function should set the $result variable at the
         end of the function, or call #return with the given result.

         To use a function use the @ character before the function name.
         The function arguments should be placed between braces behind the
         function name with argument separated by semicolons.

         The function itself can use the provided arguments which are stored
         in %1 to %9, with %0 holding all arguments.

Example: #function {rnd} {#math {result} {1 d (%2 - %1 + 1) + %1 - 1}}
         #showme A random number between 100 and 200: @rnd{100;200}

Example: #function gettime {#format result %t %H:%M}
         #showme The current time is @gettime{}

Comment: You can remove a function with the #unfunction command.

Command: #gag {string}

         Removes any line that contains the string.

Comment: See '#help action', for more information about triggers.

Comment: You can remove a gag with the #ungag command.

      ####################################################################
      #                     T I N T I N + +   2.01.8                     #
      #                                                                  #
      #                 The Kickin Tickin DikuMUD Client                 #
      #                                                                  #
      #      Code by Peter Unold, Bill Reis, and Igor van den Hoven      #
      ####################################################################

Command: #grep [page] {search string}

         This command allows you to search for matching lines in your scroll
         back buffer. The amount of matches shown equals your screen size. If
         you want to search back further use the optional page number. You can
         use wildcards for better search results. Be aware the search string
         is case sensitive, which can be disabled by using %i.

         By default grep searches from the end of the scrollback buffer to the
         beginning, this can be reversed by using a negative page number.

Example: #grep Bubba tells you
         This will show all occasions where bubba tells you something.

Command: #help {subject}

         Without an argument #help will list all available help subjects.

         Using #help %* will display all help entries.

Command: #highlight {string} {color names}

         The highlight command is used to allow you to highlight strings of text
         from the mud.  Available ANSI color names are:

         reset, light, dark, underscore, blink, reverse

         black, red, green, yellow, blue, magenta, cyan, white,
         b black, b red, b green, b yellow, b blue, b magenta, b cyan, b white

         Available XTERM 256 color names are:

         azure, ebony, jade, lime, orange, pink, silver, tan, violet,
         light azure, light ebony, light jade, light lime, light orange,
         light pink, light silver, light tan, light violet.

         The %1-99 variables can be used as 'wildcards' that will match with any
         text. They are useful for highlighting a complete line. The %0 variable
         should never be used in highlights.

         You may start the string to highlight with a ^ to only highlight text
         if it begins the line.

         Besides color names also <abc> color codes can be used.

Example: #high {Valgar} {reverse}
         Prints every occurrence of 'Valgar' in reverse video.

Example: #high {^You %1} {bold cyan}
         Boldfaces any line that starts with 'You' in cyan.

Example: #high {Bubba} {red underscore blink}
         Highlights the name Bubba as blinking, red, underscored text

Comment: See '#help action', for more information about triggers.

Comment: See '#help substitute', for more advanced color substitution.

Comment: This command only works with ANSI/VT100 terminals or emulators.

Comment: You can remove a highlight with the #unhighlight command.

Command: #history {delete}                 Delete the last command.
         #history {insert}    {command}    Insert a command.
         #history {list}                   Display the entire command history.
         #history {read}      {filename}   Read a command history from file.
         #history {write}     {filename}   Write a command history to file.

         Without an argument all available options are shown.

Command: #if {conditional} {commands if true} {commands if false}

         The 'if' command is one of the most powerful commands added since
         TINTIN III. It works similar to an 'if' statement in other languages,
         and is strictly based on the way C handles its conditional statements.
         When an 'if' command is encountered, the conditional statement is
         evaluated, and if TRUE (any non-zero result) the commands are executed.

         The 'if' statement is only evaluated if it is read, so you must nest
         the 'if' statement inside another statement (most likely an 'action'
         command). The conditional is evaluated exactly the same as in the
         'math' command only instead of storing the result, the result is used
         to determine whether to execute the commands.

Example: #action {%0 gives you %1 gold coins.} {#if {%1>5000} {thank %0}}
         If someone gives you more than 5000 coins, thank them.

Comment: See '#help math', for more information.

Command: #ignore {listname} {on|off}

         Toggles a list on or off. With no arguments it shows your current
         settings, as well as the list names that you can ignore.

         If you for example set ACTIONS to OFF actions will no longer trigger.
         Not every list can be ignored.

Command: #info {listname} {LIST|ON|OFF|SAVE}

         Without an argument info displays the settings of every tintin list.

         By providing the name of a list and the LIST option it shows all
         triggers/variables associated with that list. With the SAVE option
         This data is written to the info variable.

Trivia:  Typing: #info cpu will show information about tintin's cpu usage.

Command: #kill {list} {pattern}

         Without an argument, the kill command clears all lists.  Useful if
         you don't want to exit tintin to reload your command files.

         With one argument a specific list can be cleared.

         With two arguments the triggers in the chosen list that match the
         given pattern will be removed.

Example: #kill alias %*test*

Command: #line {option} {argument}

         #line log {filename} {[text]}          Log the current or given line to
                                                file.

         #line logverbatim {filename} {[text]}  Log text without variable
                                                substitution.

         #line gag                              Gag the next line.

         #line ignore {argument}                Argument is executed without
                                                any triggers being checked.

         #line quiet {argument}                 Argument is executed with
                                                suppression of system messages.

         #line strip {argument}                 Strips the argument of color
                                                codes next executes it as a
                                                command.

         #line substitute {options} {argument}  Substitutes the given options:
                                                variables, functions, colors,
                                                escapes, secure, in the given
                                                argument next executes it as a
                                                command.

         #line verbatim {argument}              Argument is executed verbatim.

         #line verbose {argument}               Argument is executed verbose.

         When using #line log and logging in html format use \c< \c> \c& \c" to
         log a literal < > & and ".

Command: #list {variable} {option} {argument}

         #list {var} {add} {item}               Add {item} to the list
         #list {var} {clear}                    Empty the given list
         #list {var} {create} {item}            Create a list using {items}
         #list {var} {delete} {index} {number}  Delete the item at {index},
                                                the {number} is optional.
         #list {var} {insert} {index} {string}  Insert {string} at given index
         #list {var} {find} {string} {variable} Return the found index
         #list {var} {get} {index} {variable}   Copy an item to {variable}
         #list {var} {set} {index} {string}     Change the item at {index}
         #list {var} {simplify} {variable}      Copy simple list to {variable}
         #list {var} {size} {variable}          Copy list size to {variable}
         #list {var} {sort} {string}            Insert item in alphabetic order
         #list {var} {tokenize} {string}        Create a character list

         The index should be between 1 and the list's length. You can also give
         a negative value, in which case -1 equals the last item in the list, -2
         the second last, etc.

         When inserting an item a positive index will prepend the item at the
         given index, while a negative index will append the item.

         The add and create options allow using multiple items, as well
         as semicolon separated items.

         A length of 0 is returned for an empty or non existant list.

         You can directly access elements in a list variable using $var[1],
         $var[2], $var[-1], etc.

Command: #local {variable name} {text to fill variable}

         The local command sets a local variable. Unlike a regular variable
         a local variable will only stay in memory for the duration of the
         event that created it. They are accessed in the same way as a
         regular variable.

         Commands that store information to a variable will use a local variable
         if it exists.

         Avoid setting the result variable as local in a function.

Example: #alias {swap} {#local x %0;#replace x {e} {u};#showme $x}

Command: #log {append|overwrite} {filename}

         Logs session to a file, you can set the data type to either plain,
         raw, or html with the config command.

Command: #loop {<start>} {<finish>} {<variable>} {commands}

         Like a for statement, loop will loop from start to finish incrementing
         or decrementing by 1 each time through.  The value of the loop counter
         is stored in the provided variable, which you can use in the commands.

Example: #loop 1 3 loop {get all $loop\.corpse}
         This equals 'get all 1.corpse;get all 2.corpse;get all 3.corpse'.

         The . needs to be escaped so it's not treated as part of the variable.

Example: #loop 3 1 cnt {drop $cnt\.key}
         This equals 'drop 3.key;drop 2.key;drop 1.key'.

Command: #macro {key sequence} {commands}

         Macros allow you to make tintin respond to function keys.

         The key sequence send to the terminal when pressing a function key
         differs for every OS and terminal. To find out what sequence is send
         you can enable the CONVERT META config option.

         Another option is pressing ctrl-v, which will enable CONVERT META for
         the next key pressed.

Example: #macro {(press ctrl-v)(press F1)} {#showme \e[2J;#buffer lock}
         Clear the screen and lock the window when you press F1, useful when the
         boss is near.

Example: #macro {\eOM} {#cursor enter}
         Makes the keypad's enter key work as an enter in keypad mode.

Comment: Not all terminals properly initialize the keypad key sequences.
         If this is the case you can still use the keypad, but instead of the
         arrow keys use ctrl b, f, p, and n.

Comment: You can remove a macro with the #unmacro command.

Command: #map

         The map command is the backbone of the auto mapping feature.

         #map at <location> <command>: Execute the command at the location.

         #map color <field> value: Sets the map color for the given field.

         #map create <size>: Creates a new map and room 1, required to start
                  mapping. Default size is 50000 rooms.

         #map destroy: Deletes the map.

         #map delete <exit|vnum>: Deletes the room for the given exit or vnum.

         #map dig <exit|vnum> [new|<vnum>]: Creates an exit for the given exit
                  name. If no valid exit name is given or no existing room is
                  found a new room is created. Useful for portal links and
                  other alternative forms of transportation. If the 'new'
                  argument is provided all existing rooms are ignored and a new
                  room is created. If a room vnum is given as the second
                  argument an exit will be created leading to the given room
                  vnum. If the room vnum doesn't exist a new room is created.

         #map exit <exit> <option> <arg>
                  Set the exit data. Useful with a closed door where you can
                  set the exit command: '#map exit e command {open east;e}'.
                  Use #map exit <exit> for a list of available options.

         #map exitflag <exit> <HIDE|AVOID> [on|off]
                  Set exit flags. See #map roomflag for more info.

         #map explore <exit>: Explores the given exit until a dead end or an
                  intersection is found. The route is stored in #path and can
                  subsequently be used with #walk. Useful for long roads.

         #map find <name> <exits> <desc> <area> <note> <terrain> <flag>
                  searches for the given room name. If found the shortest path
                  from your current location to the destination is calculated.
                  The route is stored in #path and can subsequently be used with
                  the various #path commands. If <exits> is provided all exits
                  must be matched, if <roomdesc>, <roomarea> or <roomnote> or
                  <roomterrain> or <roomflag> is provided these are matched as
                  well against the room to be found.
                  These options are also available to the at, delete, goto, link,

                  list and run commands.

         #map flag asciigraphics: Takes up more space but draws a more detailed
                  map that displays the ne se sw nw exits and room symbols.

         #map flag asciivnums: Display room vnums if asciigraphics is enabled.

         #map flag nofollow: When you enter movement commands the map will no
                  longer automatically follow along. Useful for MSDP and GMCP
                  automapping scripts.

         #map flag static: Will make the map static so new rooms are no longer
                  created when walking into an unmapped direction. Useful when
                  you're done mapping and regularly bump into walls accidentally
                  creating a new room. #map dig etc will still work.

         #map flag vtgraphics: Enables vt line drawing on some terminals

         #map flag vtmap: Will enable the vtmap which is shown in the top split
                  screen if you have one. You can create a 16 rows high top
                  screen by using '#split 16 1'.

         #map goto <room vnum> [dig]: Takes you to the given room vnum, with the
                  dig argument a new room will be created if non exists.

         #map goto <name> <exits> <desc> <area> <note> <terrain>: Takes you to
                  the given room name, if you provide exits those must match.

         #map get <option> <variable> [vnum]: Store a map value into a
                    variable, if no vnum is given the current room is used. Use
                    'all' as the option to store all values as a table.

         #map get roomexits <variable>: Store all room exits into variable.

         #map global <room vnum>: Set the vnum of a room that contains global
                   exits, for example an exit named 'recall' that leads to the
                   recall location. The room can contain multiple exits, in case
                   there are multiple commands that are similar to recall.

         #map info: Gives information about the map and room you are in.

         #map insert <direction> [roomflag]: Insert a room in the given
                  direction. Most useful for inserting void rooms.

         #map jump <x> <y> <z>: Jump to the given coordinate, which is relative
                  to your current room.

         #map leave: Makes you leave the map. Useful when entering a maze. You
                  can return to your last known room using #map return.

         #map legend <legend> <symbols>: There are several legends for drawing
                  maps to suit personal preference and system capabilities.
                  Use #map legend without an argument to see the currently
                  used legends. Use #map legend <legend> to set one particular
                  legend. Use #map legend <legend> <character list> to create
                  a custom legend. Custom legends are automatically saved by
                  using #map read and #map write.

         #map link <direction> <room name> [both]: Links two rooms. If the both
                  argument and a valid direction is given the link is two ways.

         #map list <name> <exits> <desc> <area> <note> <terrain>
                  Lists all matching rooms and their distance.

                  Use {variable} {<variable>} to save the output to a variable.
                  {roomname} {<name>}, {roomarea} {<area>}, etc, are valid too.

         #map map {<x>x<y>} {filename} {a|v}: shows a map of surrounding rooms.
                  The {horizontal x vertical} argument i.e 80x25 is optional,
                  and so is the filename argument to log the map output to
                  file. The {a} argument causes data to be appended so it can
                  easily be tailed with the tail -f <file> shell command.
                  The {v} argument causes the map to be stored as a variable,
                  with filename being used as the variable name.

         #map move <direction>: This does the same as an actual movement
                  command, updating your location on the map and creating new
                  rooms. Useful when you are following someone and want the map
                  to follow. You will need to create actions using '#map move',
                  for this to work.

         #map read <filename>: Will load the given map file.

         #map resize <size>: Resize the map, setting the maximum number of
                  rooms.

         #map return: Returns you to your last known room after leaving the map
                  or loading a map.

         #map roomflag avoid: When set, '#map find' will avoid a route leading
                  through that room. Useful when you want to avoid death traps.
         #map roomflag hide: When set, '#map' will not display the map beyond
                  this room. When mapping overlapping areas or areas that aren't
                  build consistently you need this flag as well to stop
                  auto-linking, unless you use void rooms.
         #map roomflag leave: When entering a room with this flag, you will
                  automatically leave the map. Useful when set at the entrance
                  of an unmappable maze.
         #map roomflag noglobal: This marks a room as not allowing global
                  transportation, like norecall rooms that block recall.
         #map roomflag void: When set the room becomes a spacing room that can
                  be used to connect otherwise overlapping areas. A void room
                  should only have two exits. When entering a void room you are
                  moved to the connecting room until you enter a non void room.
         #map roomflag static: When set the room will no longer be autolinked
                  when walking around. Useful for mapping mazes.

         #map run <room name> [delay]: Calculates the shortest path to the
                  destination and walks you there. The delay is optional and
                  requires using braces. Besides the room name a list of
                  exits can be provided for more precise matching.

         #map set <option> <value> [vnum]: Set a map value for your current
                  room, or given room if a room vnum is provided.

         #map travel <direction> <delay>: Follows the direction until a dead end
                  or an intersection is found. Use braces around the direction
                  if you use the delay, which will add the given delay between
                  movements
                  Use #undelay PATH %* to abort delayed movement.

         #map undo: Will undo your last move. If this created a room or a link
                  they will be deleted, otherwise you'll simply move back a
                  room. Useful if you walked into a non existant direction.

         #map uninsert <direction>: Exact opposite of the insert command.

         #map unlink <direction> [both]: Will remove the exit, this isn't two
                  way so you can have the map properly display no exit rooms and
                  mazes.
                  If you use the both argument the exit is removed two-ways.

         #map vnum <low> [high]: Change the room vnum to the given number, if
                  a range is provided the first available room in that range
                  is selected.

         #map write <filename>: Will save the map.

Command: #math {variable} {expression}

         Performs math operations and stores the result in a variable.  The math
         follows a C-like precedence, as follows, with the top of the list
         having the highest priority.

         Operators       Priority     Function
         ------------------------------------------------
         !               0            logical not
         ~               0            bitwise not
         *               1            integer multiply
         **              1            integer power
         /               1            integer divide
         //              1            integer sqrt // 2 or cbrt // 3
         %               1            integer modulo
         d               1            integer random dice roll
         +               2            integer addition
         -               2            integer subtraction
         <<              3            bitwise shift
         >>              3            bitwise shift
         >               4            logical greater than
         >=              4            logical greater than or equal
         <               4            logical less than
         <=              4            logical less than or equal
         ==              5            logical equal (can use regex)
         !=              5            logical not equal (can use regex)
          &              6            bitwise and
          ^              7            bitwise xor
          |              8            bitwise or
         &&              9            logical and
         ^^             10            logical xor
         ||             11            logical or

         True is any non-zero number, and False is zero.  Parentheses () have
         highest precedence, so inside the () is always evaluated first.
         Strings must be enclosed in " " and use regex with == and !=,
         in the case of <= and >= the alphabetic order is compared.

         The #if and #switch commands use #math. Several commands accepting
         integer input allow math operations as well.

         Floating point precision is added by using the decimal . operator.
         Time in seconds is calculated using [day]:[hour]:<minute>:<second>.

Example: #math {heals} {$mana / 40}
         Assuming there is a variable $mana, divides its value by 40 and stores
         the result in $heals.

Example: #action {^You receive %0 experience} {updatexp %0}
         #alias updatexp {#math {xpneed} {$xpneed - %0}
         Let's say you have a variable which stores xp needed for your next
         level.  The above will modify that variable after every kill, showing
         the amount still needed.

Example: #action {%0 tells %1}
           {#if {"%0" == "Bubba" && $afk} {reply I'm away, my friend.}}
         When you are away from keyboard, it will only reply to your friend.

Command: #message {listname} {on|off}

         This will show the message status of all your lists if typed without an
         argument. If you set for example VARIABLES to OFF you will no longer be
         spammed when correctly using the #VARIABLE and #UNVARIABLE commands.

Command: #nop {whatever}

         Short for 'no operation', and is ignored by the client.  It is useful
         for commenting in your coms file, any text after the nop and before a
         semicolon or end of line is ignored. You shouldn't put braces { } in it
         though, unless you close them properly.

Comment: By using braces you can comment out multiple lines of code in a script
         file.

         For commenting out an entire trigger and especially large sections of
         triggers you would want to use /* text */

Example: #nop This is the start of my script file.

Command: #parse {string} {variable} {commands}

         Like the loop statement, parse will loop from start to finish through
         the given string.  The value of the current character is stored in the
         provided variable.

Example: #parse {hello world} {char} {#showme $char}

Command: #path {option} {argument}

         create   Will clear the path and start path mapping.
         delete   Will delete the last move of the path.
         describe Describe the path and current position.
         destroy  Will clear the path and stop path mapping.
         goto     Go the the start, end, or given position index.
         insert   Add the given argument to the path.
         load     Load the given variable as the new path.
         map      Display the map and the current position.
         move     Move the position forward or backward. If a number is given
                  the position is changed by the given number of steps.
         run      Execute the current path, with an optional floating point
                  delay in seconds as the second argument.
         save     Save the path to a variable. You must specify whether you
                  want to save the path 'forward' or 'backward'. If you use
                  the 'length' or 'position' keywords the current length or
                  position is saved.
         swap     Switch the forward and backward path.
         unzip    Load the given speedwalk as the new path.
         walk     Take one step forward or backward.
         zip      Turn the path into a speedwalk.

Example: #path ins {unlock n;open n} {unlock s;open s}

Command: #pathdir {dir} {reversed dir} {coord}

         By default tintin sets the most commonly used movement commands
         meaning you generally don't really have to bother with pathdirs.
         Pathdirs are used by the #path and #map commands.

         The first argument is a direction, the second argument is the reversed
         direction.  The reverse direction of north is south, etc.

         The third argument is a spatial coordinate which is a power of two.
         'n' is 1, 'e' is 2, 's' is 4, 'w' is '8', 'u' is 16, 'd' is 32. The
         exception is for compound directions, whose value should be the sum
         of the values of each cardinal direction it is composed of. For
         example, 'nw' is the sum of 'n' and 'w' which is 1 + 8, so 'nw'
         needs to be given the value of 9. This value is required for the
         #map functionality to work properly.

Example: #pathdir {ue} {dw} {18}
         #pathdir {dw} {ue} {40}

Comment: You can remove a pathdir with the #unpathdir command.


A regular expression, regex or regexp is a sequence of characters that defines
a search pattern. Since the 1980s, different syntaxes for writing regular
expressions exist, the two most widely used ones being the POSIX syntax and the
similar but more advanced Perl standard. TinTin++ supports the Perl standard
known as PCRE (Perl Compatible Regular Expressions).

Regular expressions are an integral part of TinTin++, but keep in mind that
tintin doesn't allow you to use regular expressions directly, instead it uses a
simpler intermediate syntax that still allows more complex expressions when
needed.

Commands that utilize regular expressions are: action, alias, elseif, gag, grep,
highlight, if, kill, local, math, prompt, regexp, replace, substitute, switch,
variable and while. Several other commands use regular expressions in minor
ways. Fortunately the basics are very easy to learn.

TinTin++ Regular Expression

The following support is available for regular expressions.

       ^ match start of line.
       $ match of end of line.
       \ escape one character.

	 %1-%99 match of any text, stored in the corresponding index.
      %0 should be avoided in the regex, contains all matched text.
     { } embed a perl compatible regular expression, matches are stored.
   %!{ } embed a perc compatible regular expression, matches are not stored.

[ ] . + | ( ) ? * are treated as normal text unless used within braces. Keep in
mind that { } is replaced with ( ) automatically unless %!{ } is used.

TinTin++  Description                                      POSIX
%d        Match zero to any number of digits               ([0-9]*?)
%D        Match zero to any number of non-digits           ([^0-9]*?)
%i        Matches become case insensitive                  (?i)
%I        Matches become case sensitive (default)          (?-i)
%s        Match zero to any number of spaces               ([\r\n\t ]*?)
%w        Match zero to any number of word characters      ([A-Za-z0-9_]*?)
%W        Match zero to any number of non-word characters  ([^A-Za-z0-9_]*?)
%?        Match zero or one character                      (.??)
%.        Match one character                              (.)
%+        Match one to any number of characters            (.+?)
%*        Match zero to any number of characters           (.*?)

Variables

If you use %1 in an action to perform a match the matched string is stored in
the %1 variable which can be used in the action body.

Example: %1 says 'Tickle me'} {tickle %1}

If you use %2 the match is stored in %2, etc. If you use an unnumbered match
like %* or %S the match is stored at the last used index incremented by one.

Example: %3 says '%*'} {#if {"%4" == "Tickle me"} {tickle %3}}

The maximum variable index is 99. If you begin an action with %* the match is
stored in %1. You should never use %0 in the trigger part of an action, when
used in the body of an action %0 contains all the parts of the string that were
matched.

To prevent a match from being stored use %!*, %!w, etc.

Perl Compatible Regular Expressions

You can embed a PCRE (Perl Compatible Regular Expression) using curley braces
{ }, these braces are replaced with paranthesis ( ) unless you use %!{ }.

Or

You can separate alternatives within a PCRE using the | character.

Example: #act {%* scratches {his|her|its} butt.} {mutter Someone should wash %2
hands..}

Brackets

You can group alternatives and ranges within a PCRE using brackets.

Example: #act {%* says 'Who is number {[1-9]}} {say $number[%2] is number %2}

The example only triggers if someone provides a number between 1 and 9. Any
other character will cause the action to not trigger.

Example: #act {%* says 'Set password to {[^0-9]*}$} {say The password must contain
at least one number, not for security reasons, but just to annoy you.} {4}

When the ^ character is used within brackets it creates an inverse search,
[^0-9] matches every character except for a number between 0 and 9.

Quantification

A quantifier placed after a match specifies how often the match is allowed to
occur.

      ? repeat zero or one time.
      * repeat zero or multiple times.
      + repeat once or multiple times.
    {n} repeat exactly n times, n must be a number.
   {n,} repeat at least n times, n must be a number.
  {n,o} repeat between n and o times, n and o must be a number.

Example: #act {%* says 'Who is number {[1-9][0-9]{0,2}} {Say $number[%2] is number
%2}

The example only triggers if someone provides a number between 1 and 999.

Paranthesis

TinTin Regular Expressions automatically add parenthesis, for example %*
translates to (.*?) in PCRE. Paranthesis in PCRE causes a change in execution
priority similar to mathematical expressions, but paranthesis also causes the
match to be stored to a variable.

When nesting multiple sets of paranthesis each nest is assigned its own
numercial variable in order of appearance.

Example: #act {%* chats '{Mu(ha)+}'} {chat %2ha!}

If someone chats Muha you will chat Muhaha! If someone chats Muhaha you will
chat Muhahaha!

Lazy vs Greedy

By default regex matches are greedy, meaning {.*} will capture as much text as
possible.

Example: #regex {bli bla blo} {^{.*} {.*}$} {#showme Arg1=(&1) Arg2=(&2)}

This will display: Arg1=(bli bla) Arg2=(blo)

By appending a ? behind a regex it becomes lazy, meaning {.*?} will capture as
little text as possible.

Example: #regex {bli bla blo} {^{.*?} {.*?}$} {#showme Arg1=(&1) Arg2=(&2)}

This will display: Arg1=(bli) Arg2=(bla blo).

Escape Codes

PCRE support the following escape codes.

PCRE   Description                                     POSIX
\A     Match start of string                          ^
\b     Match word boundaries                          (^|\r|\n|\t| |$)
\B     Match non-word boundaries                      [^\r\n\t ]
\c     Insert control character                       \c
\d     Match digits                                   [0-9]
\D     Match non-digits                               [^0-9]
\e     Insert escape character                        \e
\f     Insert form feed character                     \f
\n     Insert line feed character                     \n
\r     Insert carriage return character               \r
\s     Match spaces                                   [\r\n\t ]
\S     Match non-spaces                               [^\r\n\t ]
\t     Insert tab character                           \t
\w     Match letters, numbers, and underscores        [A-Za-z0-9_]
\W     Match non-letters, numbers, and underscores    [^A-Za-z0-9_]
\x     Insert hex character                           \x
\Z     Match end of string                            $

\s matches one space, \s+ matches one or multiple spaces.

Color triggers

To make matching easier text triggers (Actions, Gags, Highlights, Prompts, and
Substitutes) have their color codes stripped. If you want to create a color
trigger you must start the triggers with a ~ (tilda). To make escape codes
visible use #config {convert meta} on.

Example: #action {~\e[1;37m%1} {#var roomname %1}

If the room name is the only line on the mud in bright white this color
trigger will save the roomname.


This covers the basics. PCRE has more options, most of which are somewhat
obscure, so you'll have to read a PCRE manual for additional information.

Command: #port {option} {argument}

         #port {init} {name} {port} {file}     Initilize a port session.

         #port {call}       {address} {port}   Connect to a remote socket
         #port {color}      {color names}      Set the default color
         #port {dnd}                           Decline new connections
         #port {group}      {name} {group}     Assign a socket group
         #port {ignore}     {name}             Ignore a socket
         #port {info}                          Display your info
         #port {name}       {name}             Change socket name.
         #port {prefix}     {text}             Set prefix before each message.
         #port {send}       {name|all} {text}  Send data to socket
         #port {uninitialize}                  Unitialize the port session.
         #port {who}                           Show all connections
         #port {zap}        {name}             Close a connection

         The port command is very similar to chat except that it creates a
         new session dedicated to receiving socket connections at the given
         port number without built-in support for a communication protocol.

Command: #prompt {text} {new text} {row #} {row #}

         Prompt is a feature for split window mode (see #help split), which
         will take the status prompt from the mud, and display it on the status
         line of the split window.  You would define <string> the same way you
         would a substitution (see #help substitute).

         The row number is optional and useful if you use a non standard split
         mode. A positive row number draws #row lines above the bottom row. A
         negative number draws #row lines below the title bar. The input row
         can be set using 0.

         The col number is optional and can be used to set the column index.
         A positive col number draws the given number of columns from the left,
         while a negative col number draws from the right. When a col number is
         given the line is not automatically cleared allowing multiple prompt
         calls to draw different sections of the interface.

         The #showme command takes a row and col argument as well so it's also
         possible to embed prompt drawing behavior within actions.

Comment: See '#help action', for more information about triggers.

Comment: You can remove a prompt with the #unprompt command.

Command: #read {filename}

         Reads a commands file into memory.  The coms file is merged in with
         the currently loaded commands.  Duplicate commands are overwritten.

         If you uses braces, { and } you can use several lines for 1 commands.
         This however means you must always match every { with a } for the read
         command to work.

         You can comment out triggers using /* text */

Command: #regexp {string} {expression} {true} {false}

         Compares the string to the given regular expression.

         Variables are stored in &1 to &99 with &0 holding the matched substring.

       ^ force match of start of line.
       $ force match of end of line.
       \ escape one character.
  %1-%99 lazy match of any text, available at %1-%99.
      %0 should be avoided in triggers, and if left alone lists all matches.
     { } embed a raw regular expression, matches are stored to %1-%99.
   %!{ } embed a raw regular expression, matches are not stored.
         [ ] . + | ( ) ? * are treated as normal text unlessed used within
         braces. Keep in mind that { } is replaced with ( ) automatically
         unless %!{ } is used.

         Of the following the (lazy) match is available at %1-%99 + 1

      %w match zero to any number of word characters.
      %W match zero to any number of non word characters.
      %d match zero to any number of digits.
      %D match zero to any number of non digits.
      %s match zero to any number of spaces.
      %S match zero to any number of non spaces.

      %? match zero or one character.
      %. match one character.
      %+ match one to any number of characters.
      %* match zero to any number of characters.

      %i matching becomes case insensitive.
      %I matching becomes case sensitive (default).

      The match is automatically stored to a value between %1 and %99
      starting at %1 and incrementing by 1 for every regex. If you use
      %15 as a regular expression, the next unnumbered regular expression
      would be %16. To prevent a match from being stored use %!*, %!w, etc.

Example: #regexp {bli bla blo} {bli {.*} blo} {#showme &1}

Command: #replace {variable} {oldtext} {newtext}

         Searches the variable text replacing each occurance of 'oldtext' with
         'newtext'.

Command: #return {text}

         This command can be used to break out of a command string being
         executed.

         If used inside a #function you can use #return with an argument to both
         break out of the function and set the result variable.

Command: #run {name} {shell command} {file}

         The run command works much like the system command except that it
         runs the command in a pseudo terminal. The run command also creates
         a session that treats the given shell command as a mud server. This
         allows you to run ssh, as well as any other shell application, with
         full tintin scripting capabilities. If a file name is given the file
         is loaded prior to execution.

Example: #run {somewhere} {ssh someone@somewhere.com}
Example: #run {something} {tail -f chats.log}

Command: #scan {abort|csv|tsv|txt} {filename}

         The scan txt <filename> command reads in a file and sends its content
         to the screen as if it was send by a mud. After using scan you can use
         page-up and down to view the file.

         This command is useful to convert ansi color files to html or viewing
         raw log files.

         Actions, highlights, and substitutions will trigger as normal, and it
         is possible to create an action to execute #scan abort to prematurely
         stop the scan.

         The scan csv <filename> command reads in a comma separated value file
         without printing the content to the screen. Instead it triggers one of
         two events.

         The SCAN CSV HEADER event is triggered on the first line of the csv
         file. The SCAN CSV LINE event is triggered on the second and subsequent
         lines of the csv file. The %0 argument contains the entire line, with
         %1 containing the first value, %2 the second value, etc, all the way up
         to %99.

         Values containing spaces must be surrounded with quotes, keep in mind
         newlines within quotes are not supported. Use two quotes to print one
         literal quote character.

         The scan tsv <filename> command reads in a tab separated value file
         without printing the content to the screen. Instead it triggers the
         SCAN TSV HEADER event for the first line and SCAN TSV LINE for all
         subsequent lines.

Related: textin and read.

Screen reader mode is enabled by using #config screen on. The main purpose of
the screen reader mode is to tell MUDs that a screen reader is being used by
using the MTTS standard. The MTTS specification is available at:

http://tintin.sourceforge.net/protocols/mtts

With the screen reader mode enabled TinTin++ will try to remove visual
elements where possible.

Command: #script {variable} {shell command}

         The script command works much like the system command except that it
         treats the generated echos as commands if no variable is provided.

         This is useful for running php, perl, ruby, and python scripts. You
         can run these scrips either from file or from within tintin if the
         scripting language allows this.

         If you provide a variable the output of the script is stored as a list.

Example: #script {ruby -e 'print "#showme hello world"'}
Example: #script {python -c 'print "#showme hello world"'}
Example: #script {php -r 'echo "#showme hello world"'}
Example: #script {path} {pwd};#showme The path is $path[1].

Command: #send {text}

         Sends the text directly to the MUD, useful if you want to start with an
         escape code.

Related: textin

Command: #session {name} {host} {port} {file}

         Starts a telnet session with the given name, host, port, and optional
         file name. The name can be anything you want, except the name of an
         already existant session. If a file name is given the file is only
         read if the session succesfully connects.

         Without an argument #session shows the currently defined sessions.

         If you have more than one session, you can use the following commands:
         #session {-|+|number}:  Switches between sessions.
         #{name}:  Switches to a session with the given name.
         #{name} {command}:  Executes a command with the given session without
                             changing the active session.
         @<name>{text}:      Parse text in the given session, substituting the
                             variables and functions, and print the result in
                             the current active session.

         The startup session is named 'gts' and can be used for relog scripts.

Example: #event {SESSION DISCONNECTED} {#gts #delay 10 #ses %0 mymud.com 4321}

Related: all, snoop, and zap.
Related: port, run, ssl, 

Command: #showme {string} {row} {col}

         Display the string to the terminal, do not send to the mud.  Useful for
         status, warnings, etc.  The {row} and col number are optional and work
         the same way as the row number of the #prompt trigger.

         Actions can be triggered by the showme command.

Example: #action {%0 ultraslays you.}
           {#showme {###### ARGH! We were ultraslayed by %0 ######};#gagline}
         Emphasis ultraslaying.

Command: #snoop {session name} {on|off}

         If there are multiple sessions active, this command allows you to monitor
         what is going on in the sessions that are not currently active.  The
         line of text from other sessions will be prefixed by the session's name.

         You can toggle off snoop mode by executing #snoop a second time.

         Speedwalking allows you to type multiple directions not separated by
         semicolons, and now it lets you prefix a direction with a number, to
         signify how many times to go that direction. You can turn it on/off
         with #config.

Example: Without speedwalk, you have to type:
         s;s;w;w;w;w;w;s;s;s;w;w;w;n;n;w
         With speedwalk, you only have to type:
         2s5w3s3w2nw

Command: #split {top border height} {bottom border height}

         This option only works with a VT100 emulator, this allows you to set up
         a screen.  The keyboard input will be displayed in the bottom line,
         while mud text is displayed in the main window.  This requires a fairly
         decent emulator, but works on most I have tested.

         | Top border   (can be ommited, height customizable)
         | Mud text
         | Bottom border   (height customizable, at least one line)
         | Input line

         If used without an argument, the top border will be ommited, and the
         bottom border's height will be set to one line.

         If you want a different split setting, because you want a two lines
         thick split, or like having a blank line at the top of the screen
         to display something you can set the top and bottom line with the
         additional arguments.

Example: #split
         If tintin has determined that you have a screen of 30 rows, it will
         set the main window from line #1 to line #28.

Comment: You can display text on the split line(s) with the #prompt and
         #showme {line} {row} command.

Comment: You can remove split mode with the #unsplit command.

Command: #ssl {name} {host} {port} {file}

         Starts a secure socket telnet session with the given name, host, port,
         and optional file name.

         TinTin++ knows the following statements.

         #break
         #case {value} {true}
         #continue
         #default {commands}
         #else {commands}
         #elseif {expression} {true}
         #foreach {list} {variable} {commands}
         #if {expression} {true}
         #loop {min} {max} {variable} {commands}
         #parse {string} {variable} {commands}
         #return {value}
         #switch {expression} {commands}
         #while {expression} {commands}

Command: #substitute {text} {new text}

         Allows you to replace original text from the mud with different text.
         This is helpful for complex coloring and making things more readable.
         The %1-%99 variables can be used to capture text and use it as part of
         the new output, and the ^ char is valid to only check the beginning of
         the line for the text specified.

         If only one argument is given, all active substitutions that match the
         strings are displayed.  The '%*' char is valid in this instance.  See
         '#help regex', for advanced wildcard information.

         If no argument is given, all subs are displayed.

Example: #sub {Zoe} {ZOE}
         Any instance of Zoe will be replaced with ZOE.

Example: #sub {~\e[0;34m} {\e[1;34m}
         Replace generic dark blue color codes with bright blue ones.

Example: #sub {%1massacres%2} {<018>%1<118>MASSACRES<018>%2}
         Replaces all occurrences of 'massacres' with 'MASSACRES' in red.

Comment: See '#help action', for more information about triggers.

Comment: See '#help colors', for more information.

Comment: You can remove a substitution with the #unsubstitute command.

Command: #suspend

         Temporarily suspends tintin and returns you to your shell.  The
         effect of this command is exactly as if you had typed control-z.
         To return to tintin, type 'fg' at the shell prompt.

         While suspended your tintin sessions will freeze. To keep a
         suspended session running use the screen utility program and
         have it detach the session.

Command: #switch {conditional} {arguments}

         The switch command works similar to the switch statement in other
         languages. When the 'switch' command is encountered its body is parsed
         and each 'case' command found will be compared to the conditional
         argument of the switch and executed if there is a match.

         When comparing strings the switch and case arguments must be enclosed
         in quote characters.

         If the 'default' command is found and no 'case' statement has been
         matched the default command's argument is executed.

Example: #switch {1d4} {#case 1 cackle;#case 2 smile;#default giggle}

Command: #system {command}

         Executes the command specified as a shell command.

Command: #tab {word}

         Adds a word to the tab completion list, alphabetically sorted.

         If no tabs are defined tintin will use the scrollback buffer
         for auto tab completion.

Comment: You can remove a tab with the #untab command.

Command: #textin {filename} {delay}

         Textin allows the user to read in a file, and send its contents
         directly to the mud.  Useful for doing online creation, or message
         writing.

         The delay is in seconds and takes a floating point number which is
         cumulatively applied to each outgoing line.

Related: scan and send

Command: #ticker {name} {commands} {interval in seconds}

         Executes given command every # of seconds.

Comment: Tickers don't work in the startup session.

Comment: You can remove a ticker with the #unticker command.

Command: #variable {variable name} {text to fill variable}

         Variables differ from the %0-99 arguments in the fact that you can
         specify a full word as a variable, and they stay in memory for the
         full session unless they are changed.  They can be saved in the
         coms file, and can be set to different values if you have two or
         more sessions running at the same time.  Variables are global for
         each session and can be accessed by adding a $ before the variable
         name.

Example: #alias {target} {#var target %0}
         #alias {x}      {kick $target}

         The name of a variable must exist of only letters, numbers and
         underscores in order to be substituted.  If you do not meet these
         requirements do not panic, simply encapsulate the variable in braces:

Example: #variable {cool website} {http://tintin.sourceforge.net}
         #chat I was on ${cool website} yesterday!.

         Variables can be nested using brackets or dots:

Example: #var hp[self] 34;#var hp[target] 46
Example: #var hp.self  34;#var hp.target  46

         You can see the first nest of a variable using $variable[+1] and the
         last nest using $variable[-1]. Using $variable[-2] will report the
         second last variable, and so on. To show all indices use $variable[].
         To show all values use $variable[%*] or a less generic regex.

         Nested variables are also known as tables, table generally being used
         to refer to several variables nested within one specific variable.

Example: #showme {Targets starting with the letter A: $targets[A%*]

         To see the internal index of a variable use &<variable name>. To see
         the size of a table you would use: &targets[] or &targets[%*]. A non
         existent nested variable will report itself as 0.

Example: #showme {Number of targets starting with A: &targets[A%*]

         In some scripts you need to know the name of a nested variable. This
         is also known as the key, and you can get it using *variable. For
         example *target[+1]. To get the first variable's name use *{+1}.

Comment: Related commands are local, math, format, and list.

Comment: You can remove a variable with the #unvariable command.

Command: #while {conditional} {commands}

         This command works similar to a 'while' statement in other languages.

         When a 'while' command is encourated, the conditional is evaluated,
         and if TRUE (any non-zero result) the commands are executed. The
         'while' loop will be repeated indefinitely until the conditional is
         FALSE or the #BREAK or #RETURN commands are found.

         The 'while' statement is only evaluated if it is read, so you must
         nest it inside a trigger, like an alias or action.

         The conditional is evaluated exactly the same as in the 'math' command.

Example: #math cnt 0;#while {$cnt < 20} {#math cnt $cnt + 1;say $cnt}

Comment: See '#help math', for more information.

Command: #write {filename}

         Writes all current actions, aliases, subs, highlights, and variables
         to a command file, specified by filename.

Command: #zap {[session]}

         Kill your current session.  If there is no current session, it will
         cause the program to terminate. If you provide an argument it'll zap
         the given session instead.

#OK: WRITING BUFFER TO 'help.txt'.
